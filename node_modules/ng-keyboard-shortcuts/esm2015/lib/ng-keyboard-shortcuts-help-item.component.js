import * as tslib_1 from "tslib";
import { Component, Input } from "@angular/core";
import { symbols } from "./keys";
import { identity } from './utils';
/**
 * @ignore
 */
let KeyboardShortcutsHelpItemComponent = class KeyboardShortcutsHelpItemComponent {
    constructor() { }
    set shortcut(shortcut) {
        const key = Array.isArray(shortcut.key) ? shortcut.key : [shortcut.key];
        this.parsedKeys = key.map(key => key
            .split(" ")
            .filter(identity)
            .filter(key => key !== "+")
            .map(key => {
            if (symbols[key]) {
                return symbols[key];
            }
            return key;
        }));
        this._shortcut = shortcut;
    }
    get shortcut() {
        return this._shortcut;
    }
    ngOnInit() { }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Number)
], KeyboardShortcutsHelpItemComponent.prototype, "index", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], KeyboardShortcutsHelpItemComponent.prototype, "shortcut", null);
KeyboardShortcutsHelpItemComponent = tslib_1.__decorate([
    Component({
        selector: "ng-keyboard-shortcuts-help-item",
        template: "<div class=\"item\" [class.item--odd]=\"index % 2 !== 0\" *ngIf=\"shortcut.description\">\n  <div class=\"description\">\n    <span>{{shortcut.description}}</span>\n  </div>\n  <div class=\"keys\">\n    <div *ngFor=\"let sKey of parsedKeys;let i = index\" class=\"key__container\">\n      <span class=\"key\" *ngFor=\"let key of sKey;\">{{key}}</span>\n      <span *ngIf=\"parsedKeys.length > 1 && i < parsedKeys.length - 1\" class=\"separator\"> / </span>\n    </div>\n  </div>\n</div>\n",
        styles: [".key{border:1px solid #ccc;border-radius:4px;padding:5px 12px;margin-right:5px;background-color:#f5f5f5}.key__container{display:inline-block}.separator{margin-right:5px}.keys{float:right}.item{background-color:#ebebeb;padding:12px}.description{min-width:168px;display:inline-block;color:#333}.item--odd{background-color:#fff}"]
    }),
    tslib_1.__metadata("design:paramtypes", [])
], KeyboardShortcutsHelpItemComponent);
export { KeyboardShortcutsHelpItemComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmcta2V5Ym9hcmQtc2hvcnRjdXRzLWhlbHAtaXRlbS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1rZXlib2FyZC1zaG9ydGN1dHMvIiwic291cmNlcyI6WyJsaWIvbmcta2V5Ym9hcmQtc2hvcnRjdXRzLWhlbHAtaXRlbS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBRXpELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDakMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUVuQzs7R0FFRztBQU1ILElBQWEsa0NBQWtDLEdBQS9DLE1BQWEsa0NBQWtDO0lBNEIzQyxnQkFBZSxDQUFDO0lBdEJoQixJQUFJLFFBQVEsQ0FBQyxRQUFrQjtRQUMzQixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEUsSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQzVCLEdBQUc7YUFDRSxLQUFLLENBQUMsR0FBRyxDQUFDO2FBQ1YsTUFBTSxDQUFDLFFBQVEsQ0FBQzthQUNoQixNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDO2FBQzFCLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNQLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNkLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3ZCO1lBQ0QsT0FBTyxHQUFHLENBQUM7UUFDZixDQUFDLENBQUMsQ0FDVCxDQUFDO1FBQ0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7SUFDOUIsQ0FBQztJQUNELElBQUksUUFBUTtRQUNSLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBTUQsUUFBUSxLQUFJLENBQUM7Q0FDaEIsQ0FBQTtBQTVCWTtJQUFSLEtBQUssRUFBRTs7aUVBQWU7QUFHdkI7SUFEQyxLQUFLLEVBQUU7OztrRUFnQlA7QUFyQlEsa0NBQWtDO0lBTDlDLFNBQVMsQ0FBQztRQUNQLFFBQVEsRUFBRSxpQ0FBaUM7UUFDM0Msb2ZBQStEOztLQUVsRSxDQUFDOztHQUNXLGtDQUFrQyxDQStCOUM7U0EvQlksa0NBQWtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFNob3J0Y3V0IH0gZnJvbSBcIi4vbmcta2V5Ym9hcmQtc2hvcnRjdXRzLmludGVyZmFjZXNcIjtcbmltcG9ydCB7IHN5bWJvbHMgfSBmcm9tIFwiLi9rZXlzXCI7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IFwibmcta2V5Ym9hcmQtc2hvcnRjdXRzLWhlbHAtaXRlbVwiLFxuICAgIHRlbXBsYXRlVXJsOiBcIi4vbmcta2V5Ym9hcmQtc2hvcnRjdXRzLWhlbHAtaXRlbS5jb21wb25lbnQuaHRtbFwiLFxuICAgIHN0eWxlVXJsczogW1wiLi9uZy1rZXlib2FyZC1zaG9ydGN1dHMtaGVscC1pdGVtLmNvbXBvbmVudC5jc3NcIl1cbn0pXG5leHBvcnQgY2xhc3MgS2V5Ym9hcmRTaG9ydGN1dHNIZWxwSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHVibGljIHBhcnNlZEtleXM6IHN0cmluZ1tdW107XG5cbiAgICBASW5wdXQoKSBpbmRleDogbnVtYmVyO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgc2hvcnRjdXQoc2hvcnRjdXQ6IFNob3J0Y3V0KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IEFycmF5LmlzQXJyYXkoc2hvcnRjdXQua2V5KSA/IHNob3J0Y3V0LmtleSA6IFtzaG9ydGN1dC5rZXldO1xuICAgICAgICB0aGlzLnBhcnNlZEtleXMgPSBrZXkubWFwKGtleSA9PlxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaWRlbnRpdHkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihrZXkgPT4ga2V5ICE9PSBcIitcIilcbiAgICAgICAgICAgICAgICAubWFwKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2xzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2xzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9zaG9ydGN1dCA9IHNob3J0Y3V0O1xuICAgIH1cbiAgICBnZXQgc2hvcnRjdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG9ydGN1dDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zaG9ydGN1dDogU2hvcnRjdXQ7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgICBuZ09uSW5pdCgpIHt9XG59XG4iXX0=