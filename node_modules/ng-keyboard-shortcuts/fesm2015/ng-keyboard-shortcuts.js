import { __decorate, __metadata } from 'tslib';
import { ɵɵdefineInjectable, Injectable, Input, Component, ɵɵinject, Directive, ElementRef, ViewChild, TemplateRef, ComponentFactoryResolver, ApplicationRef, ViewContainerRef, Injector, NgModule } from '@angular/core';
import { Subject, BehaviorSubject, fromEvent, timer, throwError, of } from 'rxjs';
import { filter, map, tap, throttle, catchError, switchMap, scan, takeUntil, repeat, distinctUntilChanged } from 'rxjs/operators';
import { trigger, transition, style, animate } from '@angular/animations';
import { map as map$1 } from 'rxjs/internal/operators';
import { CommonModule } from '@angular/common';

const isMac = (navigator.userAgent.indexOf('Mac OS') !== -1);
const modifiers = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'cmd': isMac ? 'metaKey' : 'ctrlKey',
    'command': isMac ? 'metaKey' : 'ctrlKey',
    'meta': isMac ? 'metaKey' : 'ctrlKey',
    'left command': 'metaKey',
    'right command': 'MetaRight',
    '⌘': isMac ? 'metaKey' : 'ctrlKey',
    'option': 'altKey',
    'ctl': 'ctrlKey',
    'control': 'ctrlKey',
};
const symbols = {
    'cmd': isMac ? '⌘' : 'Ctrl',
    'command': isMac ? '⌘' : 'Ctrl',
    'left command': isMac ? '⌘' : 'Ctrl',
    'right command': isMac ? '⌘' : 'Ctrl',
    'option': isMac ? '⌥' : 'Alt',
    'left': '←',
    'right': '→',
    'up': '↑',
    'down': '↓',
    'alt': isMac ? '⌥' : 'Alt',
    'ctrl': 'Ctrl',
    'control': 'Ctrl',
    'shift': '⇧'
};
const _MAP = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    16: 'shift',
    17: ['ctrl', 'control'],
    18: 'alt',
    20: 'capslock',
    27: ['esc', 'escape'],
    32: ['space', 'spc'],
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    45: 'ins',
    46: 'del',
    91: ['meta', 'cmd', 'command'],
    93: ['meta', 'cmd', 'command'],
    224: ['meta', 'cmd', 'command']
};
/**
 * mapping for special characters so they can support
 *
 * this dictionary is only used incase you want to bind a
 * keyup or keydown event to one of these keys
 *
 * @type
 */
const _KEYCODE_MAP = {
    106: '*',
    107: '+',
    109: '-',
    110: '.',
    111: '/',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: '\''
};
/**
 * this is a mapping of keys that require shift on a US keypad
 * back to the non shift equivelents
 *
 * this is so you can use keyup events with these keys
 *
 * note that this will only work reliably on US keyboards
 *
 */
const _SHIFT_MAP = {
    '`': '~',
    '1': '!',
    '2': '@',
    '3': '#',
    '4': '$',
    '5': '%',
    '6': '^',
    '7': '&',
    '8': '*',
    '9': '(',
    '0': ')',
    '-': '_',
    '=': '+',
    ';': ':',
    '\'': '\"',
    ',': '<',
    '.': '>',
    '/': '?',
    '\\': '|'
};
/**
 * loop through the f keys, f1 to f19 and add them to the map
 * programatically
 */
for (let i = 1; i < 20; ++i) {
    _MAP[111 + i] = 'f' + i;
}
/**
 * loop through to map numbers on the numeric keypad
 */
for (let i = 0; i <= 9; ++i) {
    // This needs to use a string cause otherwise since 0 is falsey
    // event will never fire for numpad 0 pressed as part of a keydown
    // event.
    _MAP[i + 96] = i.toString();
}

function isFunction(x) {
    return typeof x === "function";
}
const any = (fn, list) => {
    let idx = 0;
    while (idx < list.length) {
        if (fn(list[idx])) {
            return true;
        }
        idx += 1;
    }
    return false;
};
const identity = x => x;
/**
 * @ignore
 * @param x
 * @returns boolean
 */
const isNill = x => x == null;
/**
 * @ignore
 * @param xs
 * @param key
 * @returns any
 */
const groupBy = (xs, key) => xs.reduce((result, x) => (Object.assign({}, result, { [x[key]]: [...(result[x[key]] || []), x] })), {});
/**
 * @ignore
 * @param first
 * @param second
 * @returns any[]
 */
const difference = (first, second) => first.filter(item => !second.includes(item));
/**
 * @ignore
 * @param preds
 * @returns (...args) => boolean;
 */
const allPass = preds => (...args) => {
    let idx = 0;
    const len = preds.length;
    while (idx < len) {
        if (!preds[idx].apply(this, args)) {
            return false;
        }
        idx += 1;
    }
    return true;
};
const prop = prop => object => object[prop];
const maxArrayProp = (property, array) => {
    return array.reduce((acc, curr) => {
        const propFn = prop(property);
        const currentValue = propFn(curr);
        const previousValue = propFn(acc);
        return currentValue > previousValue ? curr : acc;
    }, { [property]: 0 });
};

var KeyboardShortcutsService_1;
/**
 * @ignore
 * @type {number}
 */
let guid = 0;
let KeyboardShortcutsService = KeyboardShortcutsService_1 = class KeyboardShortcutsService {
    /**
     * @ignore
     */
    constructor() {
        /**
         * Parsed shortcuts
         * for each key create a predicate function
         */
        this._shortcuts = [];
        this._sequences = [];
        /**
         * Throttle the keypress event.
         */
        this.throttleTime = 0;
        this._pressed = new Subject();
        /**
         * Streams of pressed events, can be used instead or with a command.
         */
        this.pressed$ = this._pressed.asObservable();
        /**
         * Disable all keyboard shortcuts
         */
        this.disabled = false;
        this._shortcutsSub = new BehaviorSubject([]);
        this.shortcuts$ = this._shortcutsSub
            .asObservable()
            .pipe(filter(shortcuts => !!shortcuts.length));
        this._ignored = ["INPUT", "TEXTAREA", "SELECT"];
        /**
         * @ignore
         * Subscription for on destroy.
         */
        this.subscriptions = [];
        /**
         * @ignore
         * @param shortcut
         */
        this.isAllowed = (shortcut) => {
            const target = shortcut.event.target;
            if (target === shortcut.target) {
                return true;
            }
            if (shortcut.allowIn.length) {
                return !difference(this._ignored, shortcut.allowIn).includes(target.nodeName);
            }
            return !this._ignored.includes(target.nodeName);
        };
        /**
         * @ignore
         * @param event
         */
        this.mapEvent = event => {
            return this._shortcuts
                .map(shortcut => Object.assign({}, shortcut, {
                predicates: any(identity, shortcut.predicates.map((predicates) => allPass(predicates)(event))),
                event: event
            }))
                .filter(shortcut => shortcut.predicates)
                .reduce((acc, shortcut) => (acc.priority > shortcut.priority ? acc : shortcut), {
                priority: 0
            });
        };
        /**
         * @ignore
         */
        this.keydown$ = fromEvent(document, "keydown");
        /**
         * @ignore
         */
        this.keydownCombo$ = this.keydown$.pipe(filter(_ => !this.disabled), map(this.mapEvent), filter((shortcut) => !shortcut.target || shortcut.event.target === shortcut.target), filter((shortcut) => isFunction(shortcut.command)), filter(this.isAllowed), tap(shortcut => !shortcut.preventDefault || shortcut.event.preventDefault()), throttle(shortcut => timer(shortcut.throttleTime)), tap(shortcut => shortcut.command({ event: shortcut.event, key: shortcut.key })), tap(shortcut => this._pressed.next({ event: shortcut.event, key: shortcut.key })), catchError(error => throwError(error)));
        /**
         * @ignore
         */
        this.timer$ = new Subject();
        /**
         * @ignore
         */
        this.resetCounter$ = this.timer$
            .asObservable()
            .pipe(switchMap(() => timer(KeyboardShortcutsService_1.TIMEOUT_SEQUENCE)));
        /**
         * @ignore
         */
        this.keydownSequence$ = this.shortcuts$.pipe(map(shortcuts => shortcuts.filter(shortcut => shortcut.isSequence)), switchMap(sequences => this.keydown$.pipe(map(event => {
            return {
                event,
                sequences
            };
        }), tap(this.timer$))), scan((acc, arg) => {
            let { event } = arg;
            const currentLength = acc.events.length;
            const sequences = currentLength ? acc.sequences : arg.sequences;
            let [characters] = this.characterFromEvent(event);
            characters = Array.isArray(characters) ? characters : [characters];
            const result = sequences
                .map(sequence => {
                const sequences = sequence.sequence.filter(seque => characters.some((key) => seque[currentLength] === key));
                const partialMatch = sequences.length > 0;
                if (sequence.fullMatch) {
                    return sequence;
                }
                return Object.assign({}, sequence, { sequence: sequences, partialMatch, event: event, fullMatch: partialMatch &&
                        this.isFullMatch({ command: sequence, events: acc.events }) });
            })
                .filter(sequences => sequences.partialMatch || sequences.fullMatch);
            let [match] = result;
            if (!match || this.modifiersOn(event)) {
                return { events: [], sequences: this._sequences };
            }
            /*
             * handle case of "?" sequence and "? a" sequence
             * need to determine which one to trigger.
             * if both match, we pick the longer one (? a) in this case.
             */
            const guess = maxArrayProp('priority', result);
            if (result.length > 1 && guess.fullMatch) {
                return { events: [], command: guess, sequences: this._sequences };
            }
            if (result.length > 1) {
                return { events: [...acc.events, event], command: result, sequences: result };
            }
            if (match.fullMatch) {
                return { events: [], command: match, sequences: this._sequences };
            }
            return { events: [...acc.events, event], command: result, sequences: result };
        }, { events: [], sequences: [] }), switchMap(({ command }) => {
            if (Array.isArray(command)) {
                /*
                 * Add a timer to handle the case where for example:
                 * a sequence "?" is registered and "? a" is registered as well
                 * if the user does not hit any key for 500ms, the single sequence will trigger
                 * if any keydown event occur, this timer will reset, given a chance to complete
                 * the full sequence (? a) in this case.
                 * This delay only occurs when single key sequence is the beginning of another sequence.
                 */
                return timer(500).pipe(map(() => ({ command: command.filter(command => command.fullMatch)[0] })));
            }
            return of({ command });
        }), filter(({ command }) => command && command.fullMatch), map(({ command }) => command), filter((shortcut) => isFunction(shortcut.command)), filter(this.isAllowed), tap(shortcut => !shortcut.preventDefault || shortcut.event.preventDefault()), throttle(shortcut => timer(shortcut.throttleTime)), tap(shortcut => shortcut.command({ event: shortcut.event, key: shortcut.key })), tap(shortcut => this._pressed.next({ event: shortcut.event, key: shortcut.key })), takeUntil(this.resetCounter$), repeat());
        /**
         * @ignore
         * transforms a shortcut to:
         * a predicate function
         */
        this.getKeys = (keys) => {
            return keys
                .map(key => key.trim().toLowerCase())
                .filter(key => key !== "+")
                .map(key => {
                // for modifiers like control key
                // look for event['ctrlKey']
                // otherwise use the keyCode
                if (modifiers.hasOwnProperty(key)) {
                    return event => !!event[modifiers[key]];
                }
                return event => {
                    let [characters, shiftKey] = this.characterFromEvent(event);
                    characters = Array.isArray(characters) ? characters : [characters];
                    return characters.some(char => {
                        if (char === key && shiftKey) {
                            return true;
                        }
                        return key === char;
                    });
                };
            });
        };
        this.subscriptions.push(this.keydownSequence$.subscribe(), this.keydownCombo$.subscribe());
    }
    /**
     * @ignore
     * @param command
     * @param events
     */
    isFullMatch({ command, events }) {
        if (!command) {
            return false;
        }
        return command.sequence.some(sequence => {
            return sequence.length === events.length + 1;
        });
    }
    /**
     * @ignore
     */
    get shortcuts() {
        return this._shortcuts;
    }
    /**
     * @ignore
     * @param event
     */
    _characterFromEvent(event) {
        if (typeof event.which !== "number") {
            event.which = event.keyCode;
        }
        // for non keypress events the special maps are needed
        if (_MAP[event.which]) {
            return [_MAP[event.which], event.shiftKey];
        }
        if (_KEYCODE_MAP[event.which]) {
            return [_KEYCODE_MAP[event.which], event.shiftKey];
        }
        // if it is not in the special map
        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return [String.fromCharCode(event.which).toLowerCase(), event.shiftKey];
    }
    characterFromEvent(event) {
        let [key, shiftKey] = this._characterFromEvent(event);
        if (shiftKey && _SHIFT_MAP[key]) {
            return [_SHIFT_MAP[key], shiftKey];
        }
        return [key, shiftKey];
    }
    /**
     * @ignore
     * Remove subscription.
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @ignore
     * @param shortcuts
     */
    isSequence(shortcuts) {
        return !shortcuts.some(shortcut => shortcut.includes("+"));
    }
    /**
     * Add new shortcut/s
     */
    add(shortcuts) {
        shortcuts = Array.isArray(shortcuts) ? shortcuts : [shortcuts];
        const commands = this.parseCommand(shortcuts);
        commands.forEach(command => {
            if (command.isSequence) {
                this._sequences.push(command);
                return;
            }
            this._shortcuts.push(command);
        });
        setTimeout(() => {
            this._shortcutsSub.next([...this._shortcuts, ...this._sequences]);
        });
        return commands.map(command => command.id);
    }
    /**
     * Remove a command based on key or array of keys.
     * can be used for cleanup.
     * @returns
     * @param ids
     */
    remove(ids) {
        ids = Array.isArray(ids) ? ids : [ids];
        this._shortcuts = this._shortcuts.filter(shortcut => !ids.includes(shortcut.id));
        this._sequences = this._sequences.filter(shortcut => !ids.includes(shortcut.id));
        setTimeout(() => {
            this._shortcutsSub.next([...this._shortcuts, ...this._sequences]);
        });
        return this;
    }
    /**
     * Returns an observable of keyboard shortcut filtered by a specific key.
     * @param key - the key to filter the observable by.
     */
    select(key) {
        return this.pressed$.pipe(filter(({ event, key: eventKeys }) => {
            eventKeys = Array.isArray(eventKeys) ? eventKeys : [eventKeys];
            return !!eventKeys.find(eventKey => eventKey === key);
        }));
    }
    /**
     * @ignore
     * @param event
     */
    modifiersOn(event) {
        return ["metaKey", "altKey", "ctrlKey"].some(mod => event[mod]);
    }
    /**
     * @ignore
     * Parse each command using getKeys function
     */
    parseCommand(command) {
        const commands = Array.isArray(command) ? command : [command];
        return commands.map(command => {
            const keys = Array.isArray(command.key) ? command.key : [command.key];
            const priority = Math.max(...keys.map(key => key.split(" ").filter(identity).length));
            const predicates = keys.map(key => this.getKeys(key.split(" ").filter(identity)));
            const isSequence = this.isSequence(keys);
            const sequence = isSequence
                ? keys.map(key => key
                    .split(" ")
                    .filter(identity)
                    .map(key => key.trim()))
                : [];
            return Object.assign({}, command, { isSequence, sequence: isSequence ? sequence : [], allowIn: command.allowIn || [], key: keys, id: `${guid++}`, throttle: isNill(command.throttleTime) ? this.throttleTime : command.throttleTime, priority: priority, predicates: predicates });
        });
    }
};
/**
 * @ignore
 * 2000 ms window to allow between key sequences otherwise
 * the sequence will reset.
 */
KeyboardShortcutsService.TIMEOUT_SEQUENCE = 1000;
KeyboardShortcutsService.ngInjectableDef = ɵɵdefineInjectable({ factory: function KeyboardShortcutsService_Factory() { return new KeyboardShortcutsService(); }, token: KeyboardShortcutsService, providedIn: "root" });
KeyboardShortcutsService = KeyboardShortcutsService_1 = __decorate([
    Injectable({
        providedIn: "root"
    }),
    __metadata("design:paramtypes", [])
], KeyboardShortcutsService);

/**
 * A component to bind global shortcuts, can be used multiple times across the app
 * will remove registered shortcuts when element is removed from DOM.
 */
let KeyboardShortcutsComponent = class KeyboardShortcutsComponent {
    /**
     * @ignore
     * @param {KeyboardShortcutsService} keyboard
     */
    constructor(keyboard) {
        this.keyboard = keyboard;
        /**
         * A list of shortcuts.
         */
        this.shortcuts = [];
        /**
         * @ignore
         * list of registered keyboard shortcuts
         * used for clean up on NgDestroy.
         */
        this.clearIds = [];
        /**
         * @ignore
         */
        this._disabled = false;
    }
    /**
     * Disable all shortcuts for this component.
     */
    set disabled(value) {
        this._disabled = value;
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
            this.clearIds = [];
        }
        if (value) {
            return;
        }
        this.clearIds = this.keyboard.add(this.shortcuts);
    }
    /**
     * @ignore
     */
    ngOnInit() { }
    /**
     * Select a key to listen to, will emit when the selected key is pressed.
     */
    select(key) {
        return this.keyboard.select(key);
    }
    /**
     * @ignore
     */
    ngAfterViewInit() { }
    /**
     * @ignore
     */
    ngOnChanges(changes) {
        if (!changes.shortcuts || !changes.shortcuts.currentValue) {
            return;
        }
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        setTimeout(() => this.clearIds = this.keyboard.add(changes.shortcuts.currentValue));
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.keyboard.remove(this.clearIds);
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], KeyboardShortcutsComponent.prototype, "shortcuts", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], KeyboardShortcutsComponent.prototype, "disabled", null);
KeyboardShortcutsComponent = __decorate([
    Component({
        selector: "ng-keyboard-shortcuts",
        template: ""
    }),
    __metadata("design:paramtypes", [KeyboardShortcutsService])
], KeyboardShortcutsComponent);

/**
 * Service to assist showing custom help screen
 */
let KeyboardShortcutsHelpService = class KeyboardShortcutsHelpService {
    /**
     * @ignore
     * @param {KeyboardShortcutsService} keyboard
     */
    constructor(keyboard) {
        this.keyboard = keyboard;
        /**
         * Observable to provide access to all registered shortcuts in the app.
         * @type {Observable<any>}
         */
        this.shortcuts$ = this.keyboard.shortcuts$.pipe(map(shortcuts => shortcuts
            .filter(shortcut => Boolean(shortcut.label) && Boolean(shortcut.description))
            .map(({ key, label, description }) => ({
            key,
            label,
            description
        }))));
    }
};
KeyboardShortcutsHelpService.ngInjectableDef = ɵɵdefineInjectable({ factory: function KeyboardShortcutsHelpService_Factory() { return new KeyboardShortcutsHelpService(ɵɵinject(KeyboardShortcutsService)); }, token: KeyboardShortcutsHelpService, providedIn: "root" });
KeyboardShortcutsHelpService = __decorate([
    Injectable({
        providedIn: "root"
    }),
    __metadata("design:paramtypes", [KeyboardShortcutsService])
], KeyboardShortcutsHelpService);

var AllowIn;
(function (AllowIn) {
    AllowIn["Textarea"] = "TEXTAREA";
    AllowIn["Input"] = "INPUT";
    AllowIn["Select"] = "SELECT";
})(AllowIn || (AllowIn = {}));

/**
 * A directive to be used with "focusable" elements, like:
 * textarea, input, select.
 */
let KeyboardShortcutsDirective = class KeyboardShortcutsDirective {
    /**
     * @ignore
     * @param {KeyboardShortcutsService} keyboard
     * @param {ElementRef} el
     */
    constructor(keyboard, el) {
        this.keyboard = keyboard;
        this.el = el;
        /**
         * @ignore
         * @type {boolean}
         * @private
         */
        this._disabled = false;
    }
    /**
     * whether to disable the shortcuts for this directive
     * @param value
     */
    set disabled(value) {
        this._disabled = value;
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        setTimeout(() => {
            if (value === false && this.ngKeyboardShortcuts) {
                this.clearIds = this.keyboard.add(this.transformInput(this.ngKeyboardShortcuts));
            }
        });
    }
    /**
     * @ignore
     * @param {Shortcut[]} shortcuts
     * @returns {any}
     */
    transformInput(shortcuts) {
        return shortcuts.map(shortcut => (Object.assign({}, shortcut, { target: this.el.nativeElement, allowIn: [AllowIn.Select, AllowIn.Input, AllowIn.Textarea] })));
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        if (!this.clearIds) {
            return;
        }
        this.keyboard.remove(this.clearIds);
    }
    /**
     * @ignore
     * @param {SimpleChanges} changes
     */
    ngOnChanges(changes) {
        const { ngKeyboardShortcuts } = changes;
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        if (!ngKeyboardShortcuts || !ngKeyboardShortcuts.currentValue) {
            return;
        }
        this.clearIds = this.keyboard.add(this.transformInput(ngKeyboardShortcuts.currentValue));
    }
};
__decorate([
    Input(),
    __metadata("design:type", Array)
], KeyboardShortcutsDirective.prototype, "ngKeyboardShortcuts", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], KeyboardShortcutsDirective.prototype, "disabled", null);
KeyboardShortcutsDirective = __decorate([
    Directive({
        selector: "[ngKeyboardShortcuts]"
    }),
    __metadata("design:paramtypes", [KeyboardShortcutsService, ElementRef])
], KeyboardShortcutsDirective);

/**
 * @ignore
 * A `Portal` is something that you want to render somewhere else.
 * It can be attach to / detached from a `PortalOutlet`.
 */
class Portal {
    /** Attach this portal to a host. */
    attach(host) {
        if (host == null) {
            // TODO: add error
            console.error("null portal error");
        }
        if (host.hasAttached()) {
            console.error("portal already attached");
            // throwPortalAlreadyAttachedError();
        }
        this._attachedHost = host;
        return host.attach(this);
    }
    /** Detach this portal from its host */
    detach() {
        let host = this._attachedHost;
        if (host == null) {
            console.error("no portal attached!");
            // throwNoPortalAttachedError();
        }
        else {
            this._attachedHost = null;
            host.detach();
        }
    }
    /** Whether this portal is attached to a host. */
    get isAttached() {
        return this._attachedHost != null;
    }
    /**
     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
     * the PortalOutlet when it is performing an `attach()` or `detach()`.
     */
    setAttachedHost(host) {
        this._attachedHost = host;
    }
}
/**
 * @ignore
 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
 */
class ComponentPortal extends Portal {
    constructor(component, viewContainerRef, injector, componentFactoryResolver) {
        super();
        this.component = component;
        this.viewContainerRef = viewContainerRef;
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
    }
}
/**
 * @ignore
 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
 */
class TemplatePortal extends Portal {
    constructor(template, viewContainerRef, context) {
        super();
        this.templateRef = template;
        this.viewContainerRef = viewContainerRef;
        this.context = context;
    }
    get origin() {
        return this.templateRef.elementRef;
    }
    /**
     * Attach the portal to the provided `PortalOutlet`.
     * When a context is provided it will override the `context` property of the `TemplatePortal`
     * instance.
     */
    attach(host, context = this.context) {
        this.context = context;
        return super.attach(host);
    }
    detach() {
        this.context = undefined;
        return super.detach();
    }
}
/**
 * @ignore
 * Partial implementation of PortalOutlet that handles attaching
 * ComponentPortal and TemplatePortal.
 */
class BasePortalOutlet {
    constructor() {
        /** Whether this host has already been permanently disposed. */
        this._isDisposed = false;
    }
    /** Whether this host has an attached portal. */
    hasAttached() {
        return !!this._attachedPortal;
    }
    /** Attaches a portal. */
    attach(portal) {
        if (!portal) {
            console.error('null portal!');
            // throwNullPortalError();
        }
        if (this.hasAttached()) {
            console.error('portal already attached');
            // throwPortalAlreadyAttachedError();
        }
        if (this._isDisposed) {
            console.error('portal out already disposed');
            // throwPortalOutletAlreadyDisposedError();
        }
        if (portal instanceof ComponentPortal) {
            this._attachedPortal = portal;
            return this.attachComponentPortal(portal);
        }
        else if (portal instanceof TemplatePortal) {
            this._attachedPortal = portal;
            return this.attachTemplatePortal(portal);
        }
        console.error('unknown portal type');
        // throwUnknownPortalTypeError();
    }
    /** Detaches a previously attached portal. */
    detach() {
        if (this._attachedPortal) {
            this._attachedPortal.setAttachedHost(null);
            this._attachedPortal = null;
        }
        this._invokeDisposeFn();
    }
    /** Permanently dispose of this portal host. */
    dispose() {
        if (this.hasAttached()) {
            this.detach();
        }
        this._invokeDisposeFn();
        this._isDisposed = true;
    }
    /** @docs-private */
    setDisposeFn(fn) {
        this._disposeFn = fn;
    }
    _invokeDisposeFn() {
        if (this._disposeFn) {
            this._disposeFn();
            this._disposeFn = null;
        }
    }
}

/**
 * @ignore
 * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
 * application context.
 */
class DomPortalOutlet extends BasePortalOutlet {
    constructor(
    /** Element into which the content is projected. */
    outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
        super();
        this.outletElement = outletElement;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._defaultInjector = _defaultInjector;
    }
    /**
     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
     * @param portal Portal to be attached
     * @returns Reference to the created component.
     */
    attachComponentPortal(portal) {
        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
        const componentFactory = resolver.resolveComponentFactory(portal.component);
        let componentRef;
        // If the portal specifies a ViewContainerRef, we will use that as the attachment point
        // for the component (in terms of Angular's component tree, not rendering).
        // When the ViewContainerRef is missing, we use the factory to create the component directly
        // and then manually attach the view to the application.
        if (portal.viewContainerRef) {
            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
            this.setDisposeFn(() => componentRef.destroy());
        }
        else {
            componentRef = componentFactory.create(portal.injector || this._defaultInjector);
            this._appRef.attachView(componentRef.hostView);
            this.setDisposeFn(() => {
                this._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
        }
        // At this point the component has been instantiated, so we move it to the location in the DOM
        // where we want it to be rendered.
        this.outletElement.appendChild(this._getComponentRootNode(componentRef));
        return componentRef;
    }
    /**
     * Attaches a template portal to the DOM as an embedded view.
     * @param portal Portal to be attached.
     * @returns Reference to the created embedded view.
     */
    attachTemplatePortal(portal) {
        let viewContainer = portal.viewContainerRef;
        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
        viewRef.detectChanges();
        // The method `createEmbeddedView` will add the view as a child of the viewContainer.
        // But for the DomPortalOutlet the view can be added everywhere in the DOM
        // (e.g Overlay Container) To move the view to the specified host element. We just
        // re-append the existing root nodes.
        viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));
        this.setDisposeFn((() => {
            let index = viewContainer.indexOf(viewRef);
            if (index !== -1) {
                viewContainer.remove(index);
            }
        }));
        return viewRef;
    }
    /**
     * Clears out a portal from the DOM.
     */
    dispose() {
        super.dispose();
        if (this.outletElement.parentNode != null) {
            this.outletElement.parentNode.removeChild(this.outletElement);
        }
    }
    /** Gets the root HTMLElement for an instantiated component. */
    _getComponentRootNode(componentRef) {
        return componentRef.hostView.rootNodes[0];
    }
}

/**
 * @ignore
 */
const scrollAbleKeys = new Map([[31, 1], [38, 1], [39, 1], [40, 1]]);
/**
 * @ignore
 */
const preventDefault = (ignore) => e => {
    const modal = e.target.closest(ignore);
    if (modal) {
        return;
    }
    e = e || window.event;
    if (e.preventDefault)
        e.preventDefault();
    e.returnValue = false;
};
/**
 * @ignore
 */
const preventDefaultForScrollKeys = e => {
    if (!scrollAbleKeys.has(e.keyCode)) {
        return;
    }
    return false;
};
/**
 * @ignore
 */
let scrollEvents = [{ name: 'wheel', callback: null }, { name: 'touchmove', callback: null }, { name: 'DOMMouseScroll', callback: null }];
/**
 * @ignore
 */
const disableScroll = (ignore) => {
    scrollEvents = scrollEvents.map(event => {
        const callback = preventDefault(ignore);
        window.addEventListener(event.name, callback, { passive: false });
        return Object.assign({}, event, { callback });
    });
    window.addEventListener('keydown', preventDefaultForScrollKeys);
};
/**
 * @ignore
 */
const enableScroll = () => {
    scrollEvents = scrollEvents.map(event => {
        window.removeEventListener(event.name, event.callback);
        return Object.assign({}, event, { callback: null });
    });
    window.removeEventListener('keydown', preventDefaultForScrollKeys);
};
/**
 * A Component to show all registered shortcut in the app
 * it is shown as a modal
 */
let KeyboardShortcutsHelpComponent = class KeyboardShortcutsHelpComponent {
    /**
     * @ignore
     */
    constructor(componentFactoryResolver, appRef, keyboard, element, keyboardHelp, viewContainer, injector) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.keyboard = keyboard;
        this.element = element;
        this.keyboardHelp = keyboardHelp;
        this.viewContainer = viewContainer;
        this.injector = injector;
        /**
         * Disable scrolling while modal is open
         */
        this.disableScrolling = true;
        this.className = 'help-modal';
        /**
         * The title of the help screen
         * @default: "Keyboard shortcuts"
         */
        this.title = "Keyboard shortcuts";
        /**
         * What message to show when no shortcuts are available on the page.
         * @default "No shortcuts available"
         */
        this.emptyMessage = "No shortcuts available";
        /**
         * @ignore
         */
        this.showing = false;
        this.bodyPortalHost = new DomPortalOutlet(document.body, this.componentFactoryResolver, this.appRef, this.injector);
    }
    /**
     * The shortcut to show/hide the help screen
     */
    set key(value) {
        this._key = value;
        if (!value) {
            return;
        }
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        this.clearIds = this.keyboard.add({
            key: value,
            preventDefault: true,
            command: () => this.toggle()
        });
    }
    set closeKey(value) {
        this._closeKey = value;
        if (!value) {
            return;
        }
        if (this.closeKeyIds) {
            this.keyboard.remove(this.closeKeyIds);
        }
        this.closeKeyIds = this.keyboard.add({
            key: value,
            preventDefault: true,
            command: () => this.hide()
        });
    }
    /**
     * Reveal the help screen manually.
     */
    reveal() {
        this.hide();
        if (this.disableScrolling) {
            disableScroll(`.${this.className}`);
        }
        const portal = new TemplatePortal(this.template, this.viewContainer);
        this.bodyPortalHost.attach(portal);
        this.showing = true;
        return this;
    }
    /**
     * Check if help screen is visible.
     * @returns boolean
     */
    visible() {
        return this.bodyPortalHost.hasAttached();
    }
    /**
     * Hide the help screen manually.
     */
    hide() {
        if (this.disableScrolling) {
            enableScroll();
        }
        if (!this.bodyPortalHost.hasAttached()) {
            return this;
        }
        this.bodyPortalHost.detach();
        this.showing = false;
        return this;
    }
    /**
     * @ignore
     */
    ngOnDestroy() {
        this.hide();
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        if (this.closeKeyIds) {
            this.keyboard.remove(this.closeKeyIds);
        }
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }
    }
    /**
     * Show/Hide the help screen manually.
     */
    toggle() {
        this.visible() ? this.hide() : this.reveal();
        return this;
    }
    /**
     * @ignore
     */
    ngOnInit() {
        this.subscription = this.keyboardHelp.shortcuts$
            .pipe(distinctUntilChanged(), map$1(shortcuts => groupBy(shortcuts, "label")))
            .subscribe(shortcuts => {
            this.shortcuts = shortcuts;
            this.labels = Object.keys(shortcuts);
        });
    }
};
__decorate([
    Input(),
    __metadata("design:type", Object)
], KeyboardShortcutsHelpComponent.prototype, "disableScrolling", void 0);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], KeyboardShortcutsHelpComponent.prototype, "key", null);
__decorate([
    Input(),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], KeyboardShortcutsHelpComponent.prototype, "closeKey", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], KeyboardShortcutsHelpComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], KeyboardShortcutsHelpComponent.prototype, "emptyMessage", void 0);
__decorate([
    ViewChild(TemplateRef, { static: false }),
    __metadata("design:type", TemplateRef)
], KeyboardShortcutsHelpComponent.prototype, "template", void 0);
KeyboardShortcutsHelpComponent = __decorate([
    Component({
        selector: "ng-keyboard-shortcuts-help",
        template: "<ng-template>\n    <div class=\"help-modal__container\">\n        <div class=\"{{className}}\" [@enterAnimation] *ngIf=\"showing\">\n            <div class=\"title\">\n                <h3 class=\"title__text\">{{title}}</h3>\n            </div>\n            <div class=\"help-modal__body\">\n                <span *ngIf=\"!labels.length\">\n                    {{emptyMessage}}\n                </span>\n                <div>\n                    <ul *ngFor=\"let label of labels\" class=\"help-modal__list\">\n                        <h4 class=\"item-group-label\">{{label}}</h4>\n                        <ng-keyboard-shortcuts-help-item\n                                *ngFor=\"let shortcut of shortcuts[label]; let i = index\"\n                                [shortcut]=\"shortcut\"\n                                [index]=\"i\"\n                        ></ng-keyboard-shortcuts-help-item>\n                    </ul>\n                </div>\n            </div>\n        </div>\n        <div class=\"help-modal__backdrop\" [@overlayAnimation] (click)=\"hide()\" *ngIf=\"showing\"></div>\n    </div>\n</ng-template>\n",
        animations: [
            trigger("enterAnimation", [
                transition(":enter", [
                    style({ transform: "translateX(-100%)", opacity: 0 }),
                    animate("0.33s cubic-bezier(0,0,0.3,1)", style({ transform: "translateX(0)", opacity: 1 }))
                ]),
                transition(":leave", [
                    style({ transform: "translateX(0)", opacity: 1 }),
                    animate("0.23s cubic-bezier(0,0,0.3,1)", style({ transform: "translateX(-100%)", opacity: 0 }))
                ])
            ]),
            trigger("overlayAnimation", [
                transition(":enter", [
                    style({ opacity: 0 }),
                    animate("1s cubic-bezier(0,0,0.3,1)", style({ opacity: 1 }))
                ]),
                transition(":leave", [
                    style({ opacity: 1 }),
                    animate("1s cubic-bezier(0,0,0.3,1)", style({ opacity: 0 }))
                ])
            ])
        ],
        styles: [".help-modal__container{position:fixed;top:0;right:0;z-index:10000;left:0;bottom:0;display:flex;align-items:center;justify-content:center}.help-modal{z-index:1000;min-width:420px;max-height:calc(100% - 100px);overflow:auto;padding:20px;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);background:#fff}.item-group-label{text-transform:capitalize}.title{padding:20px 0}.title__text{margin:0;padding:0}.help-modal__list{padding:0}.help-modal__backdrop{position:absolute;background:rgba(0,0,0,.27);top:0;bottom:0;left:0;right:0;z-index:500;pointer-events:auto;-webkit-tap-highlight-color:transparent;opacity:1}"]
    }),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        ApplicationRef,
        KeyboardShortcutsService,
        ElementRef,
        KeyboardShortcutsHelpService,
        ViewContainerRef,
        Injector])
], KeyboardShortcutsHelpComponent);

/**
 * @ignore
 */
let KeyboardShortcutsHelpItemComponent = class KeyboardShortcutsHelpItemComponent {
    constructor() { }
    set shortcut(shortcut) {
        const key = Array.isArray(shortcut.key) ? shortcut.key : [shortcut.key];
        this.parsedKeys = key.map(key => key
            .split(" ")
            .filter(identity)
            .filter(key => key !== "+")
            .map(key => {
            if (symbols[key]) {
                return symbols[key];
            }
            return key;
        }));
        this._shortcut = shortcut;
    }
    get shortcut() {
        return this._shortcut;
    }
    ngOnInit() { }
};
__decorate([
    Input(),
    __metadata("design:type", Number)
], KeyboardShortcutsHelpItemComponent.prototype, "index", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], KeyboardShortcutsHelpItemComponent.prototype, "shortcut", null);
KeyboardShortcutsHelpItemComponent = __decorate([
    Component({
        selector: "ng-keyboard-shortcuts-help-item",
        template: "<div class=\"item\" [class.item--odd]=\"index % 2 !== 0\" *ngIf=\"shortcut.description\">\n  <div class=\"description\">\n    <span>{{shortcut.description}}</span>\n  </div>\n  <div class=\"keys\">\n    <div *ngFor=\"let sKey of parsedKeys;let i = index\" class=\"key__container\">\n      <span class=\"key\" *ngFor=\"let key of sKey;\">{{key}}</span>\n      <span *ngIf=\"parsedKeys.length > 1 && i < parsedKeys.length - 1\" class=\"separator\"> / </span>\n    </div>\n  </div>\n</div>\n",
        styles: [".key{border:1px solid #ccc;border-radius:4px;padding:5px 12px;margin-right:5px;background-color:#f5f5f5}.key__container{display:inline-block}.separator{margin-right:5px}.keys{float:right}.item{background-color:#ebebeb;padding:12px}.description{min-width:168px;display:inline-block;color:#333}.item--odd{background-color:#fff}"]
    }),
    __metadata("design:paramtypes", [])
], KeyboardShortcutsHelpItemComponent);

var KeyboardShortcutsModule_1;
let KeyboardShortcutsModule = KeyboardShortcutsModule_1 = class KeyboardShortcutsModule {
    static forRoot() {
        return {
            ngModule: KeyboardShortcutsModule_1,
            providers: [
                KeyboardShortcutsService,
                KeyboardShortcutsHelpService
            ]
        };
    }
};
KeyboardShortcutsModule = KeyboardShortcutsModule_1 = __decorate([
    NgModule({
        imports: [CommonModule],
        entryComponents: [KeyboardShortcutsHelpComponent],
        declarations: [KeyboardShortcutsComponent, KeyboardShortcutsDirective, KeyboardShortcutsHelpComponent, KeyboardShortcutsHelpItemComponent],
        exports: [KeyboardShortcutsComponent, KeyboardShortcutsDirective, KeyboardShortcutsHelpComponent]
    })
], KeyboardShortcutsModule);

if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector ||
        Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
    Element.prototype.closest = function (s) {
        let el = this;
        do {
            if (el.matches(s))
                return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
if (!Array.prototype.flat) {
    Array.prototype.flat = function (depth) {
        var flattend = [];
        (function flat(array, depth) {
            for (let el of array) {
                if (Array.isArray(el) && depth > 0) {
                    flat(el, depth - 1);
                }
                else {
                    flattend.push(el);
                }
            }
        })(this, Math.floor(depth) || 1);
        return flattend;
    };
}
if (!Array.prototype.flatMap) {
    Array.prototype.flatMap = function () {
        return Array.prototype.map.apply(this, arguments).flat(1);
    };
}

export { AllowIn, KeyboardShortcutsComponent, KeyboardShortcutsDirective, KeyboardShortcutsHelpComponent, KeyboardShortcutsHelpService, KeyboardShortcutsModule, KeyboardShortcutsService as ɵa, KeyboardShortcutsHelpItemComponent as ɵb };
//# sourceMappingURL=ng-keyboard-shortcuts.js.map
