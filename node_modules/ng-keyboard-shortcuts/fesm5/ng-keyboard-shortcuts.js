import { __assign, __spread, __read, __decorate, __metadata, __extends } from 'tslib';
import { defineInjectable, Injectable, Input, Component, inject, Directive, ElementRef, ViewChild, TemplateRef, ComponentFactoryResolver, ApplicationRef, ViewContainerRef, Injector, NgModule } from '@angular/core';
import { Subject, BehaviorSubject, fromEvent, timer, throwError, of } from 'rxjs';
import { filter, map, tap, throttle, catchError, switchMap, scan, takeUntil, repeat, distinctUntilChanged } from 'rxjs/operators';
import { trigger, transition, style, animate } from '@angular/animations';
import { map as map$1 } from 'rxjs/internal/operators';
import { CommonModule } from '@angular/common';

var isMac = (navigator.userAgent.indexOf('Mac OS') !== -1);
var modifiers = {
    'shift': 'shiftKey',
    'ctrl': 'ctrlKey',
    'alt': 'altKey',
    'cmd': isMac ? 'metaKey' : 'ctrlKey',
    'command': isMac ? 'metaKey' : 'ctrlKey',
    'meta': isMac ? 'metaKey' : 'ctrlKey',
    'left command': 'metaKey',
    'right command': 'MetaRight',
    '⌘': isMac ? 'metaKey' : 'ctrlKey',
    'option': 'altKey',
    'ctl': 'ctrlKey',
    'control': 'ctrlKey',
};
var symbols = {
    'cmd': isMac ? '⌘' : 'Ctrl',
    'command': isMac ? '⌘' : 'Ctrl',
    'left command': isMac ? '⌘' : 'Ctrl',
    'right command': isMac ? '⌘' : 'Ctrl',
    'option': isMac ? '⌥' : 'Alt',
    'left': '←',
    'right': '→',
    'up': '↑',
    'down': '↓',
    'alt': isMac ? '⌥' : 'Alt',
    'ctrl': 'Ctrl',
    'control': 'Ctrl',
    'shift': '⇧'
};
var _MAP = {
    8: 'backspace',
    9: 'tab',
    13: 'enter',
    16: 'shift',
    17: ['ctrl', 'control'],
    18: 'alt',
    20: 'capslock',
    27: ['esc', 'escape'],
    32: ['space', 'spc'],
    33: 'pageup',
    34: 'pagedown',
    35: 'end',
    36: 'home',
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down',
    45: 'ins',
    46: 'del',
    91: ['meta', 'cmd', 'command'],
    93: ['meta', 'cmd', 'command'],
    224: ['meta', 'cmd', 'command']
};
/**
 * mapping for special characters so they can support
 *
 * this dictionary is only used incase you want to bind a
 * keyup or keydown event to one of these keys
 *
 * @type
 */
var _KEYCODE_MAP = {
    106: '*',
    107: '+',
    109: '-',
    110: '.',
    111: '/',
    186: ';',
    187: '=',
    188: ',',
    189: '-',
    190: '.',
    191: '/',
    192: '`',
    219: '[',
    220: '\\',
    221: ']',
    222: '\''
};
/**
 * this is a mapping of keys that require shift on a US keypad
 * back to the non shift equivelents
 *
 * this is so you can use keyup events with these keys
 *
 * note that this will only work reliably on US keyboards
 *
 */
var _SHIFT_MAP = {
    '`': '~',
    '1': '!',
    '2': '@',
    '3': '#',
    '4': '$',
    '5': '%',
    '6': '^',
    '7': '&',
    '8': '*',
    '9': '(',
    '0': ')',
    '-': '_',
    '=': '+',
    ';': ':',
    '\'': '\"',
    ',': '<',
    '.': '>',
    '/': '?',
    '\\': '|'
};
/**
 * loop through the f keys, f1 to f19 and add them to the map
 * programatically
 */
for (var i = 1; i < 20; ++i) {
    _MAP[111 + i] = 'f' + i;
}
/**
 * loop through to map numbers on the numeric keypad
 */
for (var i = 0; i <= 9; ++i) {
    // This needs to use a string cause otherwise since 0 is falsey
    // event will never fire for numpad 0 pressed as part of a keydown
    // event.
    _MAP[i + 96] = i.toString();
}

var _this = this;
function isFunction(x) {
    return typeof x === "function";
}
var any = function (fn, list) {
    var idx = 0;
    while (idx < list.length) {
        if (fn(list[idx])) {
            return true;
        }
        idx += 1;
    }
    return false;
};
var identity = function (x) { return x; };
/**
 * @ignore
 * @param x
 * @returns boolean
 */
var isNill = function (x) { return x == null; };
/**
 * @ignore
 * @param xs
 * @param key
 * @returns any
 */
var groupBy = function (xs, key) {
    return xs.reduce(function (result, x) {
        var _a;
        return (__assign({}, result, (_a = {}, _a[x[key]] = __spread((result[x[key]] || []), [x]), _a)));
    }, {});
};
/**
 * @ignore
 * @param first
 * @param second
 * @returns any[]
 */
var difference = function (first, second) {
    return first.filter(function (item) { return !second.includes(item); });
};
/**
 * @ignore
 * @param preds
 * @returns (...args) => boolean;
 */
var allPass = function (preds) { return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
        if (!preds[idx].apply(_this, args)) {
            return false;
        }
        idx += 1;
    }
    return true;
}; };
var prop = function (prop) { return function (object) { return object[prop]; }; };
var maxArrayProp = function (property, array) {
    var _a;
    return array.reduce(function (acc, curr) {
        var propFn = prop(property);
        var currentValue = propFn(curr);
        var previousValue = propFn(acc);
        return currentValue > previousValue ? curr : acc;
    }, (_a = {}, _a[property] = 0, _a));
};

/**
 * @ignore
 * @type {number}
 */
var guid = 0;
var KeyboardShortcutsService = /** @class */ (function () {
    /**
     * @ignore
     */
    function KeyboardShortcutsService() {
        var _this = this;
        /**
         * Parsed shortcuts
         * for each key create a predicate function
         */
        this._shortcuts = [];
        this._sequences = [];
        /**
         * Throttle the keypress event.
         */
        this.throttleTime = 0;
        this._pressed = new Subject();
        /**
         * Streams of pressed events, can be used instead or with a command.
         */
        this.pressed$ = this._pressed.asObservable();
        /**
         * Disable all keyboard shortcuts
         */
        this.disabled = false;
        this._shortcutsSub = new BehaviorSubject([]);
        this.shortcuts$ = this._shortcutsSub
            .asObservable()
            .pipe(filter(function (shortcuts) { return !!shortcuts.length; }));
        this._ignored = ["INPUT", "TEXTAREA", "SELECT"];
        /**
         * @ignore
         * Subscription for on destroy.
         */
        this.subscriptions = [];
        /**
         * @ignore
         * @param shortcut
         */
        this.isAllowed = function (shortcut) {
            var target = shortcut.event.target;
            if (target === shortcut.target) {
                return true;
            }
            if (shortcut.allowIn.length) {
                return !difference(_this._ignored, shortcut.allowIn).includes(target.nodeName);
            }
            return !_this._ignored.includes(target.nodeName);
        };
        /**
         * @ignore
         * @param event
         */
        this.mapEvent = function (event) {
            return _this._shortcuts
                .map(function (shortcut) {
                return Object.assign({}, shortcut, {
                    predicates: any(identity, shortcut.predicates.map(function (predicates) { return allPass(predicates)(event); })),
                    event: event
                });
            })
                .filter(function (shortcut) { return shortcut.predicates; })
                .reduce(function (acc, shortcut) { return (acc.priority > shortcut.priority ? acc : shortcut); }, {
                priority: 0
            });
        };
        /**
         * @ignore
         */
        this.keydown$ = fromEvent(document, "keydown");
        /**
         * @ignore
         */
        this.keydownCombo$ = this.keydown$.pipe(filter(function (_) { return !_this.disabled; }), map(this.mapEvent), filter(function (shortcut) {
            return !shortcut.target || shortcut.event.target === shortcut.target;
        }), filter(function (shortcut) { return isFunction(shortcut.command); }), filter(this.isAllowed), tap(function (shortcut) { return !shortcut.preventDefault || shortcut.event.preventDefault(); }), throttle(function (shortcut) { return timer(shortcut.throttleTime); }), tap(function (shortcut) { return shortcut.command({ event: shortcut.event, key: shortcut.key }); }), tap(function (shortcut) { return _this._pressed.next({ event: shortcut.event, key: shortcut.key }); }), catchError(function (error) { return throwError(error); }));
        /**
         * @ignore
         */
        this.timer$ = new Subject();
        /**
         * @ignore
         */
        this.resetCounter$ = this.timer$
            .asObservable()
            .pipe(switchMap(function () { return timer(KeyboardShortcutsService_1.TIMEOUT_SEQUENCE); }));
        /**
         * @ignore
         */
        this.keydownSequence$ = this.shortcuts$.pipe(map(function (shortcuts) { return shortcuts.filter(function (shortcut) { return shortcut.isSequence; }); }), switchMap(function (sequences) {
            return _this.keydown$.pipe(map(function (event) {
                return {
                    event: event,
                    sequences: sequences
                };
            }), tap(_this.timer$));
        }), scan(function (acc, arg) {
            var event = arg.event;
            var currentLength = acc.events.length;
            var sequences = currentLength ? acc.sequences : arg.sequences;
            var _a = __read(_this.characterFromEvent(event), 1), characters = _a[0];
            characters = Array.isArray(characters) ? characters : [characters];
            var result = sequences
                .map(function (sequence) {
                var sequences = sequence.sequence.filter(function (seque) { return characters.some(function (key) { return seque[currentLength] === key; }); });
                var partialMatch = sequences.length > 0;
                if (sequence.fullMatch) {
                    return sequence;
                }
                return __assign({}, sequence, { sequence: sequences, partialMatch: partialMatch, event: event, fullMatch: partialMatch &&
                        _this.isFullMatch({ command: sequence, events: acc.events }) });
            })
                .filter(function (sequences) { return sequences.partialMatch || sequences.fullMatch; });
            var _b = __read(result, 1), match = _b[0];
            if (!match || _this.modifiersOn(event)) {
                return { events: [], sequences: _this._sequences };
            }
            /*
             * handle case of "?" sequence and "? a" sequence
             * need to determine which one to trigger.
             * if both match, we pick the longer one (? a) in this case.
             */
            var guess = maxArrayProp('priority', result);
            if (result.length > 1 && guess.fullMatch) {
                return { events: [], command: guess, sequences: _this._sequences };
            }
            if (result.length > 1) {
                return { events: __spread(acc.events, [event]), command: result, sequences: result };
            }
            if (match.fullMatch) {
                return { events: [], command: match, sequences: _this._sequences };
            }
            return { events: __spread(acc.events, [event]), command: result, sequences: result };
        }, { events: [], sequences: [] }), switchMap(function (_a) {
            var command = _a.command;
            if (Array.isArray(command)) {
                /*
                 * Add a timer to handle the case where for example:
                 * a sequence "?" is registered and "? a" is registered as well
                 * if the user does not hit any key for 500ms, the single sequence will trigger
                 * if any keydown event occur, this timer will reset, given a chance to complete
                 * the full sequence (? a) in this case.
                 * This delay only occurs when single key sequence is the beginning of another sequence.
                 */
                return timer(500).pipe(map(function () { return ({ command: command.filter(function (command) { return command.fullMatch; })[0] }); }));
            }
            return of({ command: command });
        }), filter(function (_a) {
            var command = _a.command;
            return command && command.fullMatch;
        }), map(function (_a) {
            var command = _a.command;
            return command;
        }), filter(function (shortcut) { return isFunction(shortcut.command); }), filter(this.isAllowed), tap(function (shortcut) { return !shortcut.preventDefault || shortcut.event.preventDefault(); }), throttle(function (shortcut) { return timer(shortcut.throttleTime); }), tap(function (shortcut) { return shortcut.command({ event: shortcut.event, key: shortcut.key }); }), tap(function (shortcut) { return _this._pressed.next({ event: shortcut.event, key: shortcut.key }); }), takeUntil(this.resetCounter$), repeat());
        /**
         * @ignore
         * transforms a shortcut to:
         * a predicate function
         */
        this.getKeys = function (keys) {
            return keys
                .map(function (key) { return key.trim().toLowerCase(); })
                .filter(function (key) { return key !== "+"; })
                .map(function (key) {
                // for modifiers like control key
                // look for event['ctrlKey']
                // otherwise use the keyCode
                if (modifiers.hasOwnProperty(key)) {
                    return function (event) { return !!event[modifiers[key]]; };
                }
                return function (event) {
                    var _a = __read(_this.characterFromEvent(event), 2), characters = _a[0], shiftKey = _a[1];
                    characters = Array.isArray(characters) ? characters : [characters];
                    return characters.some(function (char) {
                        if (char === key && shiftKey) {
                            return true;
                        }
                        return key === char;
                    });
                };
            });
        };
        this.subscriptions.push(this.keydownSequence$.subscribe(), this.keydownCombo$.subscribe());
    }
    KeyboardShortcutsService_1 = KeyboardShortcutsService;
    /**
     * @ignore
     * @param command
     * @param events
     */
    KeyboardShortcutsService.prototype.isFullMatch = function (_a) {
        var command = _a.command, events = _a.events;
        if (!command) {
            return false;
        }
        return command.sequence.some(function (sequence) {
            return sequence.length === events.length + 1;
        });
    };
    Object.defineProperty(KeyboardShortcutsService.prototype, "shortcuts", {
        /**
         * @ignore
         */
        get: function () {
            return this._shortcuts;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     * @param event
     */
    KeyboardShortcutsService.prototype._characterFromEvent = function (event) {
        if (typeof event.which !== "number") {
            event.which = event.keyCode;
        }
        // for non keypress events the special maps are needed
        if (_MAP[event.which]) {
            return [_MAP[event.which], event.shiftKey];
        }
        if (_KEYCODE_MAP[event.which]) {
            return [_KEYCODE_MAP[event.which], event.shiftKey];
        }
        // if it is not in the special map
        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return [String.fromCharCode(event.which).toLowerCase(), event.shiftKey];
    };
    KeyboardShortcutsService.prototype.characterFromEvent = function (event) {
        var _a = __read(this._characterFromEvent(event), 2), key = _a[0], shiftKey = _a[1];
        if (shiftKey && _SHIFT_MAP[key]) {
            return [_SHIFT_MAP[key], shiftKey];
        }
        return [key, shiftKey];
    };
    /**
     * @ignore
     * Remove subscription.
     */
    KeyboardShortcutsService.prototype.ngOnDestroy = function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * @ignore
     * @param shortcuts
     */
    KeyboardShortcutsService.prototype.isSequence = function (shortcuts) {
        return !shortcuts.some(function (shortcut) { return shortcut.includes("+"); });
    };
    /**
     * Add new shortcut/s
     */
    KeyboardShortcutsService.prototype.add = function (shortcuts) {
        var _this = this;
        shortcuts = Array.isArray(shortcuts) ? shortcuts : [shortcuts];
        var commands = this.parseCommand(shortcuts);
        commands.forEach(function (command) {
            if (command.isSequence) {
                _this._sequences.push(command);
                return;
            }
            _this._shortcuts.push(command);
        });
        setTimeout(function () {
            _this._shortcutsSub.next(__spread(_this._shortcuts, _this._sequences));
        });
        return commands.map(function (command) { return command.id; });
    };
    /**
     * Remove a command based on key or array of keys.
     * can be used for cleanup.
     * @returns
     * @param ids
     */
    KeyboardShortcutsService.prototype.remove = function (ids) {
        var _this = this;
        ids = Array.isArray(ids) ? ids : [ids];
        this._shortcuts = this._shortcuts.filter(function (shortcut) { return !ids.includes(shortcut.id); });
        this._sequences = this._sequences.filter(function (shortcut) { return !ids.includes(shortcut.id); });
        setTimeout(function () {
            _this._shortcutsSub.next(__spread(_this._shortcuts, _this._sequences));
        });
        return this;
    };
    /**
     * Returns an observable of keyboard shortcut filtered by a specific key.
     * @param key - the key to filter the observable by.
     */
    KeyboardShortcutsService.prototype.select = function (key) {
        return this.pressed$.pipe(filter(function (_a) {
            var event = _a.event, eventKeys = _a.key;
            eventKeys = Array.isArray(eventKeys) ? eventKeys : [eventKeys];
            return !!eventKeys.find(function (eventKey) { return eventKey === key; });
        }));
    };
    /**
     * @ignore
     * @param event
     */
    KeyboardShortcutsService.prototype.modifiersOn = function (event) {
        return ["metaKey", "altKey", "ctrlKey"].some(function (mod) { return event[mod]; });
    };
    /**
     * @ignore
     * Parse each command using getKeys function
     */
    KeyboardShortcutsService.prototype.parseCommand = function (command) {
        var _this = this;
        var commands = Array.isArray(command) ? command : [command];
        return commands.map(function (command) {
            var keys = Array.isArray(command.key) ? command.key : [command.key];
            var priority = Math.max.apply(Math, __spread(keys.map(function (key) { return key.split(" ").filter(identity).length; })));
            var predicates = keys.map(function (key) { return _this.getKeys(key.split(" ").filter(identity)); });
            var isSequence = _this.isSequence(keys);
            var sequence = isSequence
                ? keys.map(function (key) {
                    return key
                        .split(" ")
                        .filter(identity)
                        .map(function (key) { return key.trim(); });
                })
                : [];
            return __assign({}, command, { isSequence: isSequence, sequence: isSequence ? sequence : [], allowIn: command.allowIn || [], key: keys, id: "" + guid++, throttle: isNill(command.throttleTime) ? _this.throttleTime : command.throttleTime, priority: priority, predicates: predicates });
        });
    };
    var KeyboardShortcutsService_1;
    /**
     * @ignore
     * 2000 ms window to allow between key sequences otherwise
     * the sequence will reset.
     */
    KeyboardShortcutsService.TIMEOUT_SEQUENCE = 1000;
    KeyboardShortcutsService.ngInjectableDef = defineInjectable({ factory: function KeyboardShortcutsService_Factory() { return new KeyboardShortcutsService(); }, token: KeyboardShortcutsService, providedIn: "root" });
    KeyboardShortcutsService = KeyboardShortcutsService_1 = __decorate([
        Injectable({
            providedIn: "root"
        }),
        __metadata("design:paramtypes", [])
    ], KeyboardShortcutsService);
    return KeyboardShortcutsService;
}());

/**
 * A component to bind global shortcuts, can be used multiple times across the app
 * will remove registered shortcuts when element is removed from DOM.
 */
var KeyboardShortcutsComponent = /** @class */ (function () {
    /**
     * @ignore
     * @param {KeyboardShortcutsService} keyboard
     */
    function KeyboardShortcutsComponent(keyboard) {
        this.keyboard = keyboard;
        /**
         * A list of shortcuts.
         */
        this.shortcuts = [];
        /**
         * @ignore
         * list of registered keyboard shortcuts
         * used for clean up on NgDestroy.
         */
        this.clearIds = [];
        /**
         * @ignore
         */
        this._disabled = false;
    }
    Object.defineProperty(KeyboardShortcutsComponent.prototype, "disabled", {
        /**
         * Disable all shortcuts for this component.
         */
        set: function (value) {
            this._disabled = value;
            if (this.clearIds) {
                this.keyboard.remove(this.clearIds);
                this.clearIds = [];
            }
            if (value) {
                return;
            }
            this.clearIds = this.keyboard.add(this.shortcuts);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    KeyboardShortcutsComponent.prototype.ngOnInit = function () { };
    /**
     * Select a key to listen to, will emit when the selected key is pressed.
     */
    KeyboardShortcutsComponent.prototype.select = function (key) {
        return this.keyboard.select(key);
    };
    /**
     * @ignore
     */
    KeyboardShortcutsComponent.prototype.ngAfterViewInit = function () { };
    /**
     * @ignore
     */
    KeyboardShortcutsComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (!changes.shortcuts || !changes.shortcuts.currentValue) {
            return;
        }
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        setTimeout(function () { return _this.clearIds = _this.keyboard.add(changes.shortcuts.currentValue); });
    };
    /**
     * @ignore
     */
    KeyboardShortcutsComponent.prototype.ngOnDestroy = function () {
        this.keyboard.remove(this.clearIds);
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KeyboardShortcutsComponent.prototype, "shortcuts", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], KeyboardShortcutsComponent.prototype, "disabled", null);
    KeyboardShortcutsComponent = __decorate([
        Component({
            selector: "ng-keyboard-shortcuts",
            template: ""
        }),
        __metadata("design:paramtypes", [KeyboardShortcutsService])
    ], KeyboardShortcutsComponent);
    return KeyboardShortcutsComponent;
}());

/**
 * Service to assist showing custom help screen
 */
var KeyboardShortcutsHelpService = /** @class */ (function () {
    /**
     * @ignore
     * @param {KeyboardShortcutsService} keyboard
     */
    function KeyboardShortcutsHelpService(keyboard) {
        this.keyboard = keyboard;
        /**
         * Observable to provide access to all registered shortcuts in the app.
         * @type {Observable<any>}
         */
        this.shortcuts$ = this.keyboard.shortcuts$.pipe(map(function (shortcuts) {
            return shortcuts
                .filter(function (shortcut) { return Boolean(shortcut.label) && Boolean(shortcut.description); })
                .map(function (_a) {
                var key = _a.key, label = _a.label, description = _a.description;
                return ({
                    key: key,
                    label: label,
                    description: description
                });
            });
        }));
    }
    KeyboardShortcutsHelpService.ngInjectableDef = defineInjectable({ factory: function KeyboardShortcutsHelpService_Factory() { return new KeyboardShortcutsHelpService(inject(KeyboardShortcutsService)); }, token: KeyboardShortcutsHelpService, providedIn: "root" });
    KeyboardShortcutsHelpService = __decorate([
        Injectable({
            providedIn: "root"
        }),
        __metadata("design:paramtypes", [KeyboardShortcutsService])
    ], KeyboardShortcutsHelpService);
    return KeyboardShortcutsHelpService;
}());

var AllowIn;
(function (AllowIn) {
    AllowIn["Textarea"] = "TEXTAREA";
    AllowIn["Input"] = "INPUT";
    AllowIn["Select"] = "SELECT";
})(AllowIn || (AllowIn = {}));

/**
 * A directive to be used with "focusable" elements, like:
 * textarea, input, select.
 */
var KeyboardShortcutsDirective = /** @class */ (function () {
    /**
     * @ignore
     * @param {KeyboardShortcutsService} keyboard
     * @param {ElementRef} el
     */
    function KeyboardShortcutsDirective(keyboard, el) {
        this.keyboard = keyboard;
        this.el = el;
        /**
         * @ignore
         * @type {boolean}
         * @private
         */
        this._disabled = false;
    }
    Object.defineProperty(KeyboardShortcutsDirective.prototype, "disabled", {
        /**
         * whether to disable the shortcuts for this directive
         * @param value
         */
        set: function (value) {
            var _this = this;
            this._disabled = value;
            if (this.clearIds) {
                this.keyboard.remove(this.clearIds);
            }
            setTimeout(function () {
                if (value === false && _this.ngKeyboardShortcuts) {
                    _this.clearIds = _this.keyboard.add(_this.transformInput(_this.ngKeyboardShortcuts));
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     * @param {Shortcut[]} shortcuts
     * @returns {any}
     */
    KeyboardShortcutsDirective.prototype.transformInput = function (shortcuts) {
        var _this = this;
        return shortcuts.map(function (shortcut) { return (__assign({}, shortcut, { target: _this.el.nativeElement, allowIn: [AllowIn.Select, AllowIn.Input, AllowIn.Textarea] })); });
    };
    /**
     * @ignore
     */
    KeyboardShortcutsDirective.prototype.ngOnDestroy = function () {
        if (!this.clearIds) {
            return;
        }
        this.keyboard.remove(this.clearIds);
    };
    /**
     * @ignore
     * @param {SimpleChanges} changes
     */
    KeyboardShortcutsDirective.prototype.ngOnChanges = function (changes) {
        var ngKeyboardShortcuts = changes.ngKeyboardShortcuts;
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        if (!ngKeyboardShortcuts || !ngKeyboardShortcuts.currentValue) {
            return;
        }
        this.clearIds = this.keyboard.add(this.transformInput(ngKeyboardShortcuts.currentValue));
    };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], KeyboardShortcutsDirective.prototype, "ngKeyboardShortcuts", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], KeyboardShortcutsDirective.prototype, "disabled", null);
    KeyboardShortcutsDirective = __decorate([
        Directive({
            selector: "[ngKeyboardShortcuts]"
        }),
        __metadata("design:paramtypes", [KeyboardShortcutsService, ElementRef])
    ], KeyboardShortcutsDirective);
    return KeyboardShortcutsDirective;
}());

/**
 * @ignore
 * A `Portal` is something that you want to render somewhere else.
 * It can be attach to / detached from a `PortalOutlet`.
 */
var Portal = /** @class */ (function () {
    function Portal() {
    }
    /** Attach this portal to a host. */
    Portal.prototype.attach = function (host) {
        if (host == null) {
            // TODO: add error
            console.error("null portal error");
        }
        if (host.hasAttached()) {
            console.error("portal already attached");
            // throwPortalAlreadyAttachedError();
        }
        this._attachedHost = host;
        return host.attach(this);
    };
    /** Detach this portal from its host */
    Portal.prototype.detach = function () {
        var host = this._attachedHost;
        if (host == null) {
            console.error("no portal attached!");
            // throwNoPortalAttachedError();
        }
        else {
            this._attachedHost = null;
            host.detach();
        }
    };
    Object.defineProperty(Portal.prototype, "isAttached", {
        /** Whether this portal is attached to a host. */
        get: function () {
            return this._attachedHost != null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
     * the PortalOutlet when it is performing an `attach()` or `detach()`.
     */
    Portal.prototype.setAttachedHost = function (host) {
        this._attachedHost = host;
    };
    return Portal;
}());
/**
 * @ignore
 * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
 */
var ComponentPortal = /** @class */ (function (_super) {
    __extends(ComponentPortal, _super);
    function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
        var _this = _super.call(this) || this;
        _this.component = component;
        _this.viewContainerRef = viewContainerRef;
        _this.injector = injector;
        _this.componentFactoryResolver = componentFactoryResolver;
        return _this;
    }
    return ComponentPortal;
}(Portal));
/**
 * @ignore
 * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
 */
var TemplatePortal = /** @class */ (function (_super) {
    __extends(TemplatePortal, _super);
    function TemplatePortal(template, viewContainerRef, context) {
        var _this = _super.call(this) || this;
        _this.templateRef = template;
        _this.viewContainerRef = viewContainerRef;
        _this.context = context;
        return _this;
    }
    Object.defineProperty(TemplatePortal.prototype, "origin", {
        get: function () {
            return this.templateRef.elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach the portal to the provided `PortalOutlet`.
     * When a context is provided it will override the `context` property of the `TemplatePortal`
     * instance.
     */
    TemplatePortal.prototype.attach = function (host, context) {
        if (context === void 0) { context = this.context; }
        this.context = context;
        return _super.prototype.attach.call(this, host);
    };
    TemplatePortal.prototype.detach = function () {
        this.context = undefined;
        return _super.prototype.detach.call(this);
    };
    return TemplatePortal;
}(Portal));
/**
 * @ignore
 * Partial implementation of PortalOutlet that handles attaching
 * ComponentPortal and TemplatePortal.
 */
var BasePortalOutlet = /** @class */ (function () {
    function BasePortalOutlet() {
        /** Whether this host has already been permanently disposed. */
        this._isDisposed = false;
    }
    /** Whether this host has an attached portal. */
    BasePortalOutlet.prototype.hasAttached = function () {
        return !!this._attachedPortal;
    };
    /** Attaches a portal. */
    BasePortalOutlet.prototype.attach = function (portal) {
        if (!portal) {
            console.error('null portal!');
            // throwNullPortalError();
        }
        if (this.hasAttached()) {
            console.error('portal already attached');
            // throwPortalAlreadyAttachedError();
        }
        if (this._isDisposed) {
            console.error('portal out already disposed');
            // throwPortalOutletAlreadyDisposedError();
        }
        if (portal instanceof ComponentPortal) {
            this._attachedPortal = portal;
            return this.attachComponentPortal(portal);
        }
        else if (portal instanceof TemplatePortal) {
            this._attachedPortal = portal;
            return this.attachTemplatePortal(portal);
        }
        console.error('unknown portal type');
        // throwUnknownPortalTypeError();
    };
    /** Detaches a previously attached portal. */
    BasePortalOutlet.prototype.detach = function () {
        if (this._attachedPortal) {
            this._attachedPortal.setAttachedHost(null);
            this._attachedPortal = null;
        }
        this._invokeDisposeFn();
    };
    /** Permanently dispose of this portal host. */
    BasePortalOutlet.prototype.dispose = function () {
        if (this.hasAttached()) {
            this.detach();
        }
        this._invokeDisposeFn();
        this._isDisposed = true;
    };
    /** @docs-private */
    BasePortalOutlet.prototype.setDisposeFn = function (fn) {
        this._disposeFn = fn;
    };
    BasePortalOutlet.prototype._invokeDisposeFn = function () {
        if (this._disposeFn) {
            this._disposeFn();
            this._disposeFn = null;
        }
    };
    return BasePortalOutlet;
}());

/**
 * @ignore
 * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
 * application context.
 */
var DomPortalOutlet = /** @class */ (function (_super) {
    __extends(DomPortalOutlet, _super);
    function DomPortalOutlet(
    /** Element into which the content is projected. */
    outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
        var _this = _super.call(this) || this;
        _this.outletElement = outletElement;
        _this._componentFactoryResolver = _componentFactoryResolver;
        _this._appRef = _appRef;
        _this._defaultInjector = _defaultInjector;
        return _this;
    }
    /**
     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
     * @param portal Portal to be attached
     * @returns Reference to the created component.
     */
    DomPortalOutlet.prototype.attachComponentPortal = function (portal) {
        var _this = this;
        var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
        var componentFactory = resolver.resolveComponentFactory(portal.component);
        var componentRef;
        // If the portal specifies a ViewContainerRef, we will use that as the attachment point
        // for the component (in terms of Angular's component tree, not rendering).
        // When the ViewContainerRef is missing, we use the factory to create the component directly
        // and then manually attach the view to the application.
        if (portal.viewContainerRef) {
            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
            this.setDisposeFn(function () { return componentRef.destroy(); });
        }
        else {
            componentRef = componentFactory.create(portal.injector || this._defaultInjector);
            this._appRef.attachView(componentRef.hostView);
            this.setDisposeFn(function () {
                _this._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
        }
        // At this point the component has been instantiated, so we move it to the location in the DOM
        // where we want it to be rendered.
        this.outletElement.appendChild(this._getComponentRootNode(componentRef));
        return componentRef;
    };
    /**
     * Attaches a template portal to the DOM as an embedded view.
     * @param portal Portal to be attached.
     * @returns Reference to the created embedded view.
     */
    DomPortalOutlet.prototype.attachTemplatePortal = function (portal) {
        var _this = this;
        var viewContainer = portal.viewContainerRef;
        var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
        viewRef.detectChanges();
        // The method `createEmbeddedView` will add the view as a child of the viewContainer.
        // But for the DomPortalOutlet the view can be added everywhere in the DOM
        // (e.g Overlay Container) To move the view to the specified host element. We just
        // re-append the existing root nodes.
        viewRef.rootNodes.forEach(function (rootNode) { return _this.outletElement.appendChild(rootNode); });
        this.setDisposeFn((function () {
            var index = viewContainer.indexOf(viewRef);
            if (index !== -1) {
                viewContainer.remove(index);
            }
        }));
        return viewRef;
    };
    /**
     * Clears out a portal from the DOM.
     */
    DomPortalOutlet.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this.outletElement.parentNode != null) {
            this.outletElement.parentNode.removeChild(this.outletElement);
        }
    };
    /** Gets the root HTMLElement for an instantiated component. */
    DomPortalOutlet.prototype._getComponentRootNode = function (componentRef) {
        return componentRef.hostView.rootNodes[0];
    };
    return DomPortalOutlet;
}(BasePortalOutlet));

/**
 * @ignore
 */
var scrollAbleKeys = new Map([[31, 1], [38, 1], [39, 1], [40, 1]]);
/**
 * @ignore
 */
var preventDefault = function (ignore) { return function (e) {
    var modal = e.target.closest(ignore);
    if (modal) {
        return;
    }
    e = e || window.event;
    if (e.preventDefault)
        e.preventDefault();
    e.returnValue = false;
}; };
/**
 * @ignore
 */
var preventDefaultForScrollKeys = function (e) {
    if (!scrollAbleKeys.has(e.keyCode)) {
        return;
    }
    return false;
};
/**
 * @ignore
 */
var scrollEvents = [{ name: 'wheel', callback: null }, { name: 'touchmove', callback: null }, { name: 'DOMMouseScroll', callback: null }];
/**
 * @ignore
 */
var disableScroll = function (ignore) {
    scrollEvents = scrollEvents.map(function (event) {
        var callback = preventDefault(ignore);
        window.addEventListener(event.name, callback, { passive: false });
        return __assign({}, event, { callback: callback });
    });
    window.addEventListener('keydown', preventDefaultForScrollKeys);
};
/**
 * @ignore
 */
var enableScroll = function () {
    scrollEvents = scrollEvents.map(function (event) {
        window.removeEventListener(event.name, event.callback);
        return __assign({}, event, { callback: null });
    });
    window.removeEventListener('keydown', preventDefaultForScrollKeys);
};
/**
 * A Component to show all registered shortcut in the app
 * it is shown as a modal
 */
var KeyboardShortcutsHelpComponent = /** @class */ (function () {
    /**
     * @ignore
     */
    function KeyboardShortcutsHelpComponent(componentFactoryResolver, appRef, keyboard, element, keyboardHelp, viewContainer, injector) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.keyboard = keyboard;
        this.element = element;
        this.keyboardHelp = keyboardHelp;
        this.viewContainer = viewContainer;
        this.injector = injector;
        /**
         * Disable scrolling while modal is open
         */
        this.disableScrolling = true;
        this.className = 'help-modal';
        /**
         * The title of the help screen
         * @default: "Keyboard shortcuts"
         */
        this.title = "Keyboard shortcuts";
        /**
         * What message to show when no shortcuts are available on the page.
         * @default "No shortcuts available"
         */
        this.emptyMessage = "No shortcuts available";
        /**
         * @ignore
         */
        this.showing = false;
        this.bodyPortalHost = new DomPortalOutlet(document.body, this.componentFactoryResolver, this.appRef, this.injector);
    }
    Object.defineProperty(KeyboardShortcutsHelpComponent.prototype, "key", {
        /**
         * The shortcut to show/hide the help screen
         */
        set: function (value) {
            var _this = this;
            this._key = value;
            if (!value) {
                return;
            }
            if (this.clearIds) {
                this.keyboard.remove(this.clearIds);
            }
            this.clearIds = this.keyboard.add({
                key: value,
                preventDefault: true,
                command: function () { return _this.toggle(); }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KeyboardShortcutsHelpComponent.prototype, "closeKey", {
        set: function (value) {
            var _this = this;
            this._closeKey = value;
            if (!value) {
                return;
            }
            if (this.closeKeyIds) {
                this.keyboard.remove(this.closeKeyIds);
            }
            this.closeKeyIds = this.keyboard.add({
                key: value,
                preventDefault: true,
                command: function () { return _this.hide(); }
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Reveal the help screen manually.
     */
    KeyboardShortcutsHelpComponent.prototype.reveal = function () {
        this.hide();
        if (this.disableScrolling) {
            disableScroll("." + this.className);
        }
        var portal = new TemplatePortal(this.template, this.viewContainer);
        this.bodyPortalHost.attach(portal);
        this.showing = true;
        return this;
    };
    /**
     * Check if help screen is visible.
     * @returns boolean
     */
    KeyboardShortcutsHelpComponent.prototype.visible = function () {
        return this.bodyPortalHost.hasAttached();
    };
    /**
     * Hide the help screen manually.
     */
    KeyboardShortcutsHelpComponent.prototype.hide = function () {
        if (this.disableScrolling) {
            enableScroll();
        }
        if (!this.bodyPortalHost.hasAttached()) {
            return this;
        }
        this.bodyPortalHost.detach();
        this.showing = false;
        return this;
    };
    /**
     * @ignore
     */
    KeyboardShortcutsHelpComponent.prototype.ngOnDestroy = function () {
        this.hide();
        if (this.clearIds) {
            this.keyboard.remove(this.clearIds);
        }
        if (this.closeKeyIds) {
            this.keyboard.remove(this.closeKeyIds);
        }
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
        }
    };
    /**
     * Show/Hide the help screen manually.
     */
    KeyboardShortcutsHelpComponent.prototype.toggle = function () {
        this.visible() ? this.hide() : this.reveal();
        return this;
    };
    /**
     * @ignore
     */
    KeyboardShortcutsHelpComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscription = this.keyboardHelp.shortcuts$
            .pipe(distinctUntilChanged(), map$1(function (shortcuts) { return groupBy(shortcuts, "label"); }))
            .subscribe(function (shortcuts) {
            _this.shortcuts = shortcuts;
            _this.labels = Object.keys(shortcuts);
        });
    };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KeyboardShortcutsHelpComponent.prototype, "disableScrolling", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], KeyboardShortcutsHelpComponent.prototype, "key", null);
    __decorate([
        Input(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], KeyboardShortcutsHelpComponent.prototype, "closeKey", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KeyboardShortcutsHelpComponent.prototype, "title", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], KeyboardShortcutsHelpComponent.prototype, "emptyMessage", void 0);
    __decorate([
        ViewChild(TemplateRef, { static: false }),
        __metadata("design:type", TemplateRef)
    ], KeyboardShortcutsHelpComponent.prototype, "template", void 0);
    KeyboardShortcutsHelpComponent = __decorate([
        Component({
            selector: "ng-keyboard-shortcuts-help",
            template: "<ng-template>\n    <div class=\"help-modal__container\">\n        <div class=\"{{className}}\" [@enterAnimation] *ngIf=\"showing\">\n            <div class=\"title\">\n                <h3 class=\"title__text\">{{title}}</h3>\n            </div>\n            <div class=\"help-modal__body\">\n                <span *ngIf=\"!labels.length\">\n                    {{emptyMessage}}\n                </span>\n                <div>\n                    <ul *ngFor=\"let label of labels\" class=\"help-modal__list\">\n                        <h4 class=\"item-group-label\">{{label}}</h4>\n                        <ng-keyboard-shortcuts-help-item\n                                *ngFor=\"let shortcut of shortcuts[label]; let i = index\"\n                                [shortcut]=\"shortcut\"\n                                [index]=\"i\"\n                        ></ng-keyboard-shortcuts-help-item>\n                    </ul>\n                </div>\n            </div>\n        </div>\n        <div class=\"help-modal__backdrop\" [@overlayAnimation] (click)=\"hide()\" *ngIf=\"showing\"></div>\n    </div>\n</ng-template>\n",
            animations: [
                trigger("enterAnimation", [
                    transition(":enter", [
                        style({ transform: "translateX(-100%)", opacity: 0 }),
                        animate("0.33s cubic-bezier(0,0,0.3,1)", style({ transform: "translateX(0)", opacity: 1 }))
                    ]),
                    transition(":leave", [
                        style({ transform: "translateX(0)", opacity: 1 }),
                        animate("0.23s cubic-bezier(0,0,0.3,1)", style({ transform: "translateX(-100%)", opacity: 0 }))
                    ])
                ]),
                trigger("overlayAnimation", [
                    transition(":enter", [
                        style({ opacity: 0 }),
                        animate("1s cubic-bezier(0,0,0.3,1)", style({ opacity: 1 }))
                    ]),
                    transition(":leave", [
                        style({ opacity: 1 }),
                        animate("1s cubic-bezier(0,0,0.3,1)", style({ opacity: 0 }))
                    ])
                ])
            ],
            styles: [".help-modal__container{position:fixed;top:0;right:0;z-index:10000;left:0;bottom:0;display:flex;align-items:center;justify-content:center}.help-modal{z-index:1000;min-width:420px;max-height:calc(100% - 100px);overflow:auto;padding:20px;box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12);background:#fff}.item-group-label{text-transform:capitalize}.title{padding:20px 0}.title__text{margin:0;padding:0}.help-modal__list{padding:0}.help-modal__backdrop{position:absolute;background:rgba(0,0,0,.27);top:0;bottom:0;left:0;right:0;z-index:500;pointer-events:auto;-webkit-tap-highlight-color:transparent;opacity:1}"]
        }),
        __metadata("design:paramtypes", [ComponentFactoryResolver,
            ApplicationRef,
            KeyboardShortcutsService,
            ElementRef,
            KeyboardShortcutsHelpService,
            ViewContainerRef,
            Injector])
    ], KeyboardShortcutsHelpComponent);
    return KeyboardShortcutsHelpComponent;
}());

/**
 * @ignore
 */
var KeyboardShortcutsHelpItemComponent = /** @class */ (function () {
    function KeyboardShortcutsHelpItemComponent() {
    }
    Object.defineProperty(KeyboardShortcutsHelpItemComponent.prototype, "shortcut", {
        get: function () {
            return this._shortcut;
        },
        set: function (shortcut) {
            var key = Array.isArray(shortcut.key) ? shortcut.key : [shortcut.key];
            this.parsedKeys = key.map(function (key) {
                return key
                    .split(" ")
                    .filter(identity)
                    .filter(function (key) { return key !== "+"; })
                    .map(function (key) {
                    if (symbols[key]) {
                        return symbols[key];
                    }
                    return key;
                });
            });
            this._shortcut = shortcut;
        },
        enumerable: true,
        configurable: true
    });
    KeyboardShortcutsHelpItemComponent.prototype.ngOnInit = function () { };
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], KeyboardShortcutsHelpItemComponent.prototype, "index", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], KeyboardShortcutsHelpItemComponent.prototype, "shortcut", null);
    KeyboardShortcutsHelpItemComponent = __decorate([
        Component({
            selector: "ng-keyboard-shortcuts-help-item",
            template: "<div class=\"item\" [class.item--odd]=\"index % 2 !== 0\" *ngIf=\"shortcut.description\">\n  <div class=\"description\">\n    <span>{{shortcut.description}}</span>\n  </div>\n  <div class=\"keys\">\n    <div *ngFor=\"let sKey of parsedKeys;let i = index\" class=\"key__container\">\n      <span class=\"key\" *ngFor=\"let key of sKey;\">{{key}}</span>\n      <span *ngIf=\"parsedKeys.length > 1 && i < parsedKeys.length - 1\" class=\"separator\"> / </span>\n    </div>\n  </div>\n</div>\n",
            styles: [".key{border:1px solid #ccc;border-radius:4px;padding:5px 12px;margin-right:5px;background-color:#f5f5f5}.key__container{display:inline-block}.separator{margin-right:5px}.keys{float:right}.item{background-color:#ebebeb;padding:12px}.description{min-width:168px;display:inline-block;color:#333}.item--odd{background-color:#fff}"]
        }),
        __metadata("design:paramtypes", [])
    ], KeyboardShortcutsHelpItemComponent);
    return KeyboardShortcutsHelpItemComponent;
}());

var KeyboardShortcutsModule = /** @class */ (function () {
    function KeyboardShortcutsModule() {
    }
    KeyboardShortcutsModule_1 = KeyboardShortcutsModule;
    KeyboardShortcutsModule.forRoot = function () {
        return {
            ngModule: KeyboardShortcutsModule_1,
            providers: [
                KeyboardShortcutsService,
                KeyboardShortcutsHelpService
            ]
        };
    };
    var KeyboardShortcutsModule_1;
    KeyboardShortcutsModule = KeyboardShortcutsModule_1 = __decorate([
        NgModule({
            imports: [CommonModule],
            entryComponents: [KeyboardShortcutsHelpComponent],
            declarations: [KeyboardShortcutsComponent, KeyboardShortcutsDirective, KeyboardShortcutsHelpComponent, KeyboardShortcutsHelpItemComponent],
            exports: [KeyboardShortcutsComponent, KeyboardShortcutsDirective, KeyboardShortcutsHelpComponent]
        })
    ], KeyboardShortcutsModule);
    return KeyboardShortcutsModule;
}());

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.msMatchesSelector ||
        Element.prototype.webkitMatchesSelector;
}
if (!Element.prototype.closest) {
    Element.prototype.closest = function (s) {
        var el = this;
        do {
            if (el.matches(s))
                return el;
            el = el.parentElement || el.parentNode;
        } while (el !== null && el.nodeType === 1);
        return null;
    };
}
if (!Array.prototype.flat) {
    Array.prototype.flat = function (depth) {
        var flattend = [];
        (function flat(array, depth) {
            var e_1, _a;
            try {
                for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                    var el = array_1_1.value;
                    if (Array.isArray(el) && depth > 0) {
                        flat(el, depth - 1);
                    }
                    else {
                        flattend.push(el);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        })(this, Math.floor(depth) || 1);
        return flattend;
    };
}
if (!Array.prototype.flatMap) {
    Array.prototype.flatMap = function () {
        return Array.prototype.map.apply(this, arguments).flat(1);
    };
}

export { AllowIn, KeyboardShortcutsComponent, KeyboardShortcutsDirective, KeyboardShortcutsHelpComponent, KeyboardShortcutsHelpService, KeyboardShortcutsModule, KeyboardShortcutsService as ɵa, KeyboardShortcutsHelpItemComponent as ɵb };
//# sourceMappingURL=ng-keyboard-shortcuts.js.map
